## 为什么要有交叉编译？

我们一般使用x86PC作为主，PC在一般情况下都是基于x86架构的，这两种架构的指令并不是互通的。

1. 目标机和主机是同一平台的话，就是用的普通编译器
2. 不同平台使用的就是交叉编译器

file命令：linux系统上的可执行程序一般都没有后缀名（例如.exe），也就是说我们甚至无法通过文件名来知道这个程序是在x86上运行的，还是在arm上面运行的。

于是我们可以使用file指令来获取文件的一些属性信息，比如说该程序工作在多少位的机器上，以及支持的架构，还有其他的信息。

`book@100ask:~/practice/3_dht11/no_int_dht11$ file dht11_test
dht11_test: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 4.9.0, not stripped`

## 安装交叉编译链

#### 其实就是一个解压缩的过程。

`tar -zxvf arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz -C /`

这种交叉编译工具链一般在根目录下的opt文件夹内，或者说在/usr目录下，当然这是可以自己随便定义的。

1. bin目录下一般是命令集合
2. lib目录，编译器运行的时候的库，这其中有两种库，一种是arm库，一种是x86的库，因为是在x86上面编译的，所以需要一些x86的库，至于arm库就很好理解了。

#### 使用方法

1. 直接使用命令，`arm-linux-gcc -o build 1.c`即可。但是如果系统中有多个编译器的话就会很麻烦，因为不确定这个命令指向的是哪个版本的编译器。这种办法需要提前设置PATH环境变量，具体的设置环境变量的方法如下：
	
	1.  当前terminal临时生效

	```shell
	#设置一个名为 MY_VAR 的环境变量，值为 "hello"
	export MY_VAR="hello" 
	#验证是否生效
	echo $MY_VAR   #输出：hello
	#设置路径类环境变量（如添加自定义程序路径到 PATH）
	export PATH="$PATH:/home/user/myapp/bin"	
	```
	
	2. 当前用户永久生效

    ```shell
    #编辑 .bashrc 文件
    vim ~/.bashrc
	
    #在文件末尾添加环境变量（示例）
    export JAVA_HOME="/usr/lib/jvm/java-11-openjdk"
    export PATH="$JAVA_HOME/bin:$PATH"  # 将 JAVA 命令添加到 PATH
	
    #保存后生效（无需重新登录）
    source ~/.bashrc
    ```
	​	3.  系统全局生效

    ```shell
    #用 root 权限编辑
    sudo vim /etc/profile
	
    #在文件末尾添加（示例）
    export SYSTEM_VAR="global_value"
    export PATH="/opt/common/bin:$PATH"   #添加系统级程序路径
	
    #生效（对所有新登录用户生效，当前用户需重新登录）
    source /etc/profile
    ```
	4. 系统全局生效 

    ```shell
    sudo vim /etc/environment
	
     #直接添加键值对（示例）
    MY_GLOBAL_VAR="all_users_can_see_this"
                			PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/special/bin"
    #生效（对所有新登录用户生效，当前用户需重新登录）
		 source /etc/profile
	 ```
	
2. 还可以使用绝对路径的方法（比较复杂），我们直接使用编译工具下的目录下的执行程序即可，命令会有点长。比如这样：`/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-gcc -o build 1.c`。 

#### 关于不同机器的lib库不相同

不同位的操作系统的一些库哪怕是同一个架构也是不同的，比如书在32bitx86下制作的交叉编译器，放到64bitx86下可能就会出问题。所以说我们需要在64bitpc中升级或者添加一个针对32bit的库。

ubuntu10，或者12：`sudo apt-get install ia32-libs`

ubuntu14：`sudo apt-get install libc6:i386`

32bit的libz1库：`sudo apt-get isntall lib32z1`

当然只要知道有这种升级操作就行了，等出现这种问题的时候能够联想到可能是这种原因造成的就行了。



## 工具集介绍

主要是用于分析的。

1. readelf，真正的可执行程序至少分为两部分，一部分就是代码的集合，另一部分是头信息。比如Windows是一种头（PE头），而linux就是elf头。这个头是提供给操作系统去读的。这个指令就是用于读elf文件的。

   ```shell
   book@100ask:~/practice/2_sr04/use_int_sr04$ file sr04_test
   sr04_test: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 4.9.0, with debug_info, not stripped
   book@100ask:~/practice/2_sr04/use_int_sr04$ readelf -h sr04_test
   ELF Header:
     Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
     Class:                             ELF32
     Data:                              2's complement, little endian
     Version:                           1 (current)
     OS/ABI:                            UNIX - System V
     ABI Version:                       0
     Type:                              EXEC (Executable file)
     Machine:                           ARM
     Version:                           0x1
     Entry point address:               0x10420
     Start of program headers:          52 (bytes into file)
     Start of section headers:          22236 (bytes into file)
     Flags:                             0x5000400, Version5 EABI, hard-float ABI
     Size of this header:               52 (bytes)
     Size of program headers:           32 (bytes)
     Number of program headers:         9
     Size of section headers:           40 (bytes)
     Number of section headers:         37
     Section header string table index: 36
   ```

   这里多补充一些关于elf文件的知识：

   操作系统在执行可执行文件的之后并非直接跳转到main函数运行，在运行main函数之前会先初始化一些库，还要设置栈，要做这些准备工作，如果是动态链接的话，还需要加载一些链接库，还要设置上下文，初始化cpu寄存器。于是，操作系统就从elf文件中读出一个入口地址，跳转到这个地址运行程序，这部分程序也叫做启动程序。

   在==启动程序==中，会做一些工作（以c语言为例）：初始化全局变量和静态变量，设置标准IO（初始化），解析命令行参数（传递给可执行程序的参数），设置栈帧（为main函数准备栈空间）。

   在程序return时或者可执行程序执行完毕时，程序会回到启动程序，这个时候启动程序会做一些==清理工作==，关闭标准IO流，释放相关资源，最终通过系统调用通知操作系统进程结束，回收内存等资源。

   关于==入口地址==：

   			1. 入口点地址**不是随机生成的**，而是编译链接阶段由编译器 / 链接器根据程序结构、链接脚本等确定的固定值，写入 ELF 文件头后不再变化。
   			1. 入口点地址**也不是完全固定的**，会随代码修改、编译选项、目标平台等因素变化，但同一套配置下具有确定性。
   			1. 操作系统的 ASLR 机制会影响程序在内存中的绝对执行地址，但不会改变 ELF 文件中记录的入口点偏移。

2. size，读取可执行程序大小

   ```shell
   book@100ask:~/practice/2_sr04/use_int_sr04$ size sr04_test
      text    data     bss     dec     hex filename
      2627     308       4    2939     b7b sr04_test
   ```

3. nm，读取符号列表，用于查看程序中的标签。这个符号表本身是存储于可执行程序中。

   T为全局函数标签

   D为全局变量区

   d为静态变量区，static修饰的变量

   t，static修饰的函数

4. strip，剔除符号表。我们有时候并不希望这些占用储存空间的符号表存储在可执行程序中，因为他会占用嵌入式紧张的flash资源，所以说使用这个命令剔除可执行程序中的符号表是有必要的。最终生产出的产品，会将这些符号表剔除掉。这个指令是对应x86的，如果是arm的话，就要使用前面介绍的关于交叉编译工具的知识了。

5. strings，查看程序中的一些常量字符串。

6. objdump，反汇编（主要用途）

   ```shell
   book@100ask:~/practice/3_dht11/no_int_dht11$ objdump -d build > 1.txt
   ```

7. objcopy，将代码中的一些段拷贝出来。它能够灵活地处理二进制文件。

8. addr2line，

























