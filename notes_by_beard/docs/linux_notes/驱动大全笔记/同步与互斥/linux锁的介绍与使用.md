### 锁的类型
分为两类，自旋锁（Spinning lock）和睡眠锁（sleeping lock）。
#### 自旋锁。
无法获得锁的时候，不会休眠，会一直等待下去。
1. 多cpu
保证了多cpu访问的时候，一个时间点只有一个cpu能够访问这个资源。由此可以推断自旋锁应该使用原子变量来实现的。
因为可能会造成cpu等待，所以这种锁持续的时间一定要尽可能短。临界区的代码要尽可能短，执行快。
2. 单cpu
这时的锁是为了防止别的进程来调度，因为别的进程可能会访问这个资源。内核提供了很多组函数来实现自旋锁，这些函数的后缀表达了不同的意思。有bh，irq,irqsave/restore。带irq的会直接关闭中断。
#### 睡眠锁。
无法获得锁的时候，当前线程会休眠。这种锁下面分出了很多变种。
##### 信号量，semaphore
一些任务提供资源（修改结构体中的count值），一些任务获取资源，有资源的时候就会执行，没有资源的时候就会休眠，根据没有获得信号量之后的行为分出了好几种获取资源的函数。
信号量的这种特性就决定了，它不同于原子变量，它是可以在临界区执行很多内容的，因为其他的线程或者进程或者cpu如果得不到信号量就会休眠，不会死等。
##### mutex，互斥量
它也会对资源进行提供和释放操作，但是不同于信号量，信号量能够允许多个线程去操作，但是互斥量只允许一个线程进行操作，所以它是用在一个线程的上下文的。
在临界资源被上锁到解锁的期间，其他线程想要访问这个锁就会休眠，注意这多个线程的临界区执行的内容不一定是一样的，只是说这多个临界区只能够有一个临界区在执行，由此可见互斥量并不是专属于一个线程的，多个线程都可以访问，但是能够上锁的只有一个线程。









