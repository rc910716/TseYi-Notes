## 自旋锁
### 单cpu
对于单cpu，自旋锁是没有自旋功能的。但是它会禁止抢占，preempt_disable。如果是比较老的内核，那它本身就没有抢占功能的话，spin_lock就是一个空函数。
那么如何防止中断程序来访问临界资源呢？
	把spin_lock改成spin_lock_irq就行了，执行后者会关闭中断。
类似于这种带irq后缀的还有，这些后缀代表了其不同的功能。
### 多cpu
原子变量虽然禁止了多cpu下对于临界资源的同时访问，但是他却不能够公平分配资源，所以我们在此基础上封装了一些内容。
在一个锁下面的进程都会被分配一个数字（这个数字在创建这个锁的时候就要使用函数进行获取），只有当该执行的数字等于给进程分配的数字的时候，进程才会执行，否则会死等，在死等的期间会低功耗运行，时不时地会获取该执行的数字，判断这个数字是否等于进程的数字，如果等于就会往下执行，否则就继续死等。最后unlock的时候就会执行数字加1，其他的进程或cpu就会判断自己是否应该执行了。这样就在原来的原子变量的基础上对这些临界资源的执行顺序了。

## 信号量
down函数，如果count大于0的话，就直接返回，执行下面的内容就行了。count小于0是很简单的，复杂的是count等于0的时候该如何做？
如果count等于0：
	会将当前进程放入信号量的wait_list
	修改当前进程状态修改为非RUNNING（因为除了running状态之外还有好几种状态，比如可中断和不可中断——在休眠过程中是否接受信号）
	主动放弃cpu，让别的程序运行
	如果能够运行到下面的代码的话，就代表这个进程已经被唤醒了（因为上面主动放弃了cpu），可能是因为信号量可以使用了，也有可能是被某些信号唤醒了。如果是因为信号量可用而唤醒的话，设置信号量时会设置一个标志位代表信号量可用。如果是因为某些信号唤醒的话，就会重新执行一次这一套流程。
up函数，释放信号量，如果信号量的等待链表是空的，就直接将信号量加1，然后返回。如果等待链表不空，从wait_list里面取出第一项（谁先等待，就先唤醒谁），然后从链表中删除这一项，设置信号量唤醒标志，最后唤醒得到信号量的进程。

## 互斥量
