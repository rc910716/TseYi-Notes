### 原理变量的内核实现
有两种实现方式，对于版本大于ARMv6的指令集和小于的各有一套实现方式。大于的那一套有一些特殊的指令。
1. 小于的一套：
	使用的关闭中断，然后对变量进行操作，操作完之后再恢复到关中断之前的中断状态（可能是关中断也有可能是开中断）。
	不支持SMP，也就是不支持多CPU系统，所以只要关闭了cpu就可以做到防止其他线程来抢占资源。
	
2. 大于的一套：
ldrex指令和strex指令是关键，ex后缀表示exclude，排除的意思
ldrex,会先从目标地址读入数值存在指定的寄存器中，然后标记这个数值的地址为独占访问，后面再修改这个值暂时放到寄存器里面，再使用strex写入新的值，把这个值写入指定的地址，顺便会加一个返回值以判断有没有写入成功。
	strex：如果发现要写入的地址是独占访问的，就写入新值，并清除独占访问标记，最后返回为0的返回值。
	如果被抢占，也就是说在ldrex之后有其他的线程使用了这两个指令，将这个地址的独占访问标记去掉了，就是说要写入的地址不是独占访问的情况。先判断标记位，发现非独占，然后放弃写入，最后返回1。
也就是说如果strex不成功的话就会循环进行这两个操作，直到操作成功。使用这种方式，既能够防止本身的cpu来访问，也能够防止其他cpu来访问这个变量。而且这样相比于原来关中断的做法，效率也更高。通过宏操作，可以保证无论是哪个指令集，对外的接口都是一样的。
```c
#define ATOMIC_OP(op, c_op, asm_op)					\
static inline void atomic_##op(int i, atomic_t *v)			\
{									\
	unsigned long tmp;						\
	int result;							\
									\
	prefetchw(&v->counter);						\
	__asm__ __volatile__("@ atomic_" #op "\n"			\
"1:	ldrex	%0, [%3]\n"						\
"	" #asm_op "	%0, %0, %4\n"					\
"	strex	%1, %0, [%3]\n"						\
"	teq	%1, #0\n"						\
"	bne	1b"							\
	: "=&r" (result), "=&r" (tmp), "+Qo" (v->counter)		\
	: "r" (&v->counter), "Ir" (i)					\
	: "cc");							\
}	
```

### 原子位操作
既然原子操作能够原子地修改变量的值，那么原子位操作也是理所应当成立的。