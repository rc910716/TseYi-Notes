###### 为什么要引入设备树
以前会直接将一些质量没那么高的设备相关代码（platform_device），添加进内核或者就是添加到驱动。
Linux 引入设备树（Device Tree） 主要是为了解决嵌入式系统（尤其是 ARM 架构）中硬件描述混乱、内核移植困难、代码冗余严重的问题。它是一种描述硬件资源的数据结构，独立于操作系统内核代码。在设备树出现之前（特别是 ARM Linux 早期），描述硬件的方式存在严重弊端：
1. 内核源码充斥板级细节：
	每个特定开发板（Board）的硬件细节（如：内存映射地址、中断号、GPIO 连接、外设类型和参数等）都直接硬编码在内核源码中（通常是大量的 C 头文件和板级支持包 ).
    这导致内核源码树变得极其臃肿，包含大量只为某一块板子服务的代码。
2. 内核分支爆炸：
	为不同厂商、不同型号、甚至同一芯片不同配置的开发板维护不同的内核分支或打大量补丁成为常态。
	同一个 SoC 用在不同的板子上，也需要创建几乎完全不同的内核分支，因为硬件连接细节不同。
3. 代码冗余与维护噩梦：
	大量重复的、微调的代码充斥在内核中。
	修改一个硬件配置（如更换一个按键连接的 GPIO 引脚）都需要重新编译整个内核。
	内核维护者需要为海量的、不断涌现的新开发板集成和支持这些板级细节，工作量巨大且容易出错。
4. 驱动与硬件强耦合：
	设备驱动程序通常需要包含查找其所控制硬件具体位置（地址、中断号等）的代码。这些信息是板子相关的，导致驱动代码很难在不同板子上复用。
5. 启动加载程序（Bootloader）传递硬件信息困难且不标准：
	虽然 Bootloader 最早知道硬件配置，但传统上缺乏一种标准化的、丰富的数据结构让它把完整的硬件信息传递给内核。通常只能传递非常有限的信息（如内存大小、命令行参数）。

那么我们就可以想一个其他的办法来解决这个问题：定义一个配置文件，根据这个文件来生成platform_device。
###### 查看设备树
使用下面这条反汇编命令
```shell
dtc -I dtb -O dts 100ask_imx6ull-14x14.dtb > 1.dts
```







