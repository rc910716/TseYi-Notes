###### 块设备与普通文件不是一样的
在我刚接触块设备这个概念的时候，我就认为块设备就是普通文件，今天才发现他们根本不同。
1. 有何不同：
	对于普通文件的读写是需要经过文件系统再调用存储设备对应的驱动的（也就是块设备驱动），但是对于块设备的读写是不需要经过文件系统的，是经系统调用内部的操作直接调用块设备驱动，从而将文件读写到物理存储介质中。
2. 块设备存在的意义：
	显然，虽然文件系统给文件的读取带来非常大的便利，但是这也会带来性能上的折损。在一些特定场景下，是需要不经过文件系统而能够直接访问块设备的。比如：
	数据库管理系统
	需要直接修改磁盘的底层数据（并非所有的数据都能够通过文件系统进行）
	实现一些特定的功能和应用，比如设备启动操作系统，应用于系统安装和恢复或者多系统启动
	它能够支持优化性能
###### linux内核是运行在内存上面的
在内存里面，但并不是所有的数据都是平等的，内存被分为了不同的段
###### 驱动编译进内核和insmod加载的区别
1. 编译进内核的话，这个驱动就不易进行修改，如果驱动程序出了问题，就只能够将内核换掉，而insmod的好处就是如果驱动出了问题的话，直接卸载驱动然后重启就好了。
2. 还有一个就是系统启动的原因。我们希望内核的驱动要做得尽量小一些，让里面只有一些有必要的驱动，比如屏幕，还有一些必要的应用。我们可以等系统启动之后再来一个一个的加载。
###### 驱动程序是如何知道次设备号的
应用程序调用open函数的时候会进入swi模式，可以理解为进入了内核态，进而内核调用sys_open函数，找到flash文件中存储的设备种类信息，major，minor等信息，构造出一个inode节点，来记录这些信息。
本身open函数传入的参数就有inode结构体 ，所以我们使用一个函数就可以得到minor：
```c
int minor = iminor(inode);
```
但是像是write，read这种函数如何得到次设备号等信息呢？
答案就是在file结构体里面已经存储了这些信息（或者说通过file结构体能够找到这些信息）,file结构有一个成员就是f_inode。
```c
unsigned int minor = iminor(file_inode(filp));
```




