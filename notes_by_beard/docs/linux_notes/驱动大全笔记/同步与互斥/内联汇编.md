同步与互斥离不开汇编，也可以说linux内核离不开汇编
	用汇编效率会很高
	有一些特殊算法需要优化，必须使用汇编
	调用一些特殊的指令时，需要使用汇编（高级语言无法调用）
所以我们既可以直接写一个汇编函数，也可以在c语言中内联汇编

#### 内联汇编的语法
```c
int add(int a, int b)
{
	int sum;
	__asm__ volatile(	//__asm__表示这是一个内联汇编
        "add %0, %1, %2"	//用双引号""括起来的就是我们想要执行的汇编指令，在他们的结尾可以用"\n"隔开，但是这里只有一个指令，所以没有加。		汇编指令使用%0这中方式来访问内联汇编中的操作数，先出现的就是数字小的操作数，这里的0、1、2就分别对应sum、a、b
        :"=r"(sum)	//前面的":"表示输出,=r表示用等于号修饰的这个寄存器将会被写入后面这个值
        :"r"(a), "r"(b)	//第二个":"后面表示输入,r表示会这个值会放入某个寄存器
        :"cc"	//第三个":"表示修改了哪些东西,表示出了输入操作数和输出操作数之外还影响了哪些寄存器，cc代表flags寄存器
	);
	return sum;
}
	//上面的操作中，操作数前面可以加符号名，也可以省略，加了符号名之后就可以使用符号名来访问，没加符号名就像上面这样使用编号来访问，类似下面：
int add(int a, int b)
{
	int sum;
	__asm__ volatile(
        "add %[result], %[val1], %2[val2]"	//使用符号名来访问
        :[result]"=r"(sum)	
        :[val1]"r"(a), [val2]"r"(b)	
        :"cc"	
	);
	return sum;
}
```
##### =&约束符
表示这个操作数会提前被修改，提醒编译器不要让这个数和其他数共用同一个寄存器
有时候多个数共用一个寄存器也能够实现功能，但是也有的时候我们不希望这些寄存器会被不需要地修改
