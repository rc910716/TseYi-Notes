### 模块概念

Linux内核的整体架构本就非常庞大，其包含的组件也非常多。而我们怎样把需要的部分都包含在内核中呢？

一种方法是把所有需要的功能都编译到Linux内核中。这会导致两个问题，一是生成的内核会很大，

二是如果我们要在现有的内核中新增或删除功能，将不得不重新编译内核。

有没有另一种机制可使得编译出的内核本身并不需要包含所有功能，而在这些功能需要被使用的时

候，其对应的代码被动态地加载到内核中呢？

Linux提供了这样的机制，这种机制被称为模块（Module）。模块具有这样的特点。

·模块本身不被编译入内核映像，从而控制了内核的大小。

·模块一旦被加载，它就和内核中的其他部分完全一样。

### 模块加载示例

```shell
$insmod hello.ko	//加载模块
$rmmod hello.ko		//卸载模块

$modprobe hello.ko	//加载模块的时候会加载所依赖的其他模块
$modprobe -r filename	//会同时卸载其依赖的其他模块
$modinfo module-name	//可以获得模块的信息
```

### 模块程序结构

1. 模块加载函数

   1. 当通过insmod或modprobe命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块的相关初始化工作。

2. 模块卸载函数

   1. 当通过rmmod命令卸载某模块时，模块的卸载函数会自动被内核执行，完成与模块卸载函数相反的功能。

3. 模块许可证声明

   1. 许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到内核被污染（Kernel Tainted）的警告。

      在Linux内核模块领域，可接受的LICENSE包括“GPL” 、 “GPL v2”、 “GPL and additional rights” 、 “DualBSD/GPL” 、 “Dual MPL/GPL”和“Proprietary”（关于模块是否可以采用非GPL许可权，如“Proprietary” ，这个在学术界和法律界都有争议）。

      大多数情况下，内核模块应遵循GPL兼容许可权。Linux内核模块最常见的是以MODULE_LICENSE（“GPL v2”）语句声明模块采用GPL v2。

4. 模块参数（可以选择）

   1. 模块参数是模块被加载的时候可以传递给它的值，它本身对应模块内部的全局变量。

5. 模块导出符号

   1. 内核模块可以导出的符号（symbol，对应于函数或变量），若导出，其他模块则可以使用本模块中的变量或函数。

6. 模块作者等信息声明（可选）

### 内核自加载驱动

内核可以使用==request_module(const char* fmt,  ...)==函数加载内核模块。这意味着可以在一个驱动中加载另一个驱动。

==**作用：**==

- **核心目的是“透明性”和“即插即用”**：用户无需关心底层驱动，插入设备或使用功能时，系统自动加载所需模块。
- **`request_module()` 是内核的“按需召唤术”**：当内核发现自己缺少某个功能时，它可以“召唤”用户空间的 `modprobe` 来加载对应的模块。